#version 450
#extension GL_GOOGLE_include_directive : require
#include "include/noise.glsl"
#define SCALE 0.005

layout(local_size_x = 1) in;

struct Vertex {
    float x; float y; float z;
    float nx; float ny; float nz;
    float tx; float ty; float tz;
    float bx; float by; float bz;
};

layout(std430, set=0, binding=0) buffer Src {
    Vertex src_vertices[];
};
layout(std430, set=0, binding=1) buffer Dst {
    Vertex dst_vertices[];
};
layout(set=1, binding=0) uniform ComputeData {
    vec2 u_position;
};

float get_elevation(vec2 p) {
    vec2 xz = p * SCALE;
    vec2 q = vec2(fbm(xz), fbm(xz + vec2(1.0)));

    vec2 r = vec2(
        fbm(xz + vec2(1.0) * q + vec2(1.7 + 0.15, 9.2 + 0.15)),
        fbm(xz + vec2(1.0) * q + vec2(8.3 + 0.126, 2.8 + 0.126))
    );

    return (fbm(xz + r) - 0.3) / SCALE / 2.0;
}

void main() {
    uint i = gl_GlobalInvocationID.x;
    Vertex v = src_vertices[i];
    v.x = u_position.x + v.x;
    v.z = u_position.y + v.z;
    v.y = get_elevation(vec2(v.x, v.z));

    vec3 normal = normalize(vec3(
        get_elevation(vec2((v.x - 1.0), v.z)) - get_elevation(vec2((v.x + 1.0), v.z)),
        2.0,
        get_elevation(vec2(v.x, (v.z - 1.0))) - get_elevation(vec2(v.x, (v.z + 1.0)))
    ));
    vec3 bitangent = normalize(cross(vec3(0.0, 0.0, 1.0), normal));
    vec3 tangent = normalize(cross(normal, bitangent));

    v.nx = normal.x; v.ny = normal.y; v.nz = normal.z;
    v.tx = tangent.x; v.ty = tangent.y; v.tz = tangent.z;
    v.bx = bitangent.x; v.by = bitangent.y; v.bz = bitangent.z;
    dst_vertices[i] = v;
}
